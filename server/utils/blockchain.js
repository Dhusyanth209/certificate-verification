const { ethers } = require('ethers');
const fs = require('fs');
const path = require('path');

// Contract Address - TO BE UPDATED AFTER DEPLOYMENT
// Read from file generated by deployment script
let CONTRACT_ADDRESS;
try {
    const configPath = path.join(__dirname, '../config/contract-address.json');
    if (fs.existsSync(configPath)) {
        const config = JSON.parse(fs.readFileSync(configPath, 'utf8'));
        CONTRACT_ADDRESS = config.address;
    }
} catch (error) {
    console.warn("Could not load contract address from config:", error.message);
}

CONTRACT_ADDRESS = CONTRACT_ADDRESS || process.env.CONTRACT_ADDRESS || '0x5FbDB2315678afecb367f032d93F642f64180aa3';

// RPC URL
const RPC_URL = process.env.RPC_URL || 'http://127.0.0.1:8545/';

// ABI - Read from artifacts
const ARTIFACT_PATH = path.join(__dirname, '../../smart_contracts/artifacts/contracts/CertificateRegistry.sol/CertificateRegistry.json');
let CONTRACT_ABI = [];

try {
    if (fs.existsSync(ARTIFACT_PATH)) {
        const artifact = JSON.parse(fs.readFileSync(ARTIFACT_PATH, 'utf8'));
        CONTRACT_ABI = artifact.abi;
    } else {
        console.warn("Artifact not found at:", ARTIFACT_PATH);
    }
} catch (e) {
    console.error("Error reading artifact:", e);
}

// Provider
const provider = new ethers.JsonRpcProvider(RPC_URL);

// Signer (For Issuance) - Using first account from Hardhat node
// In production, use private key from env
const PRIVATE_KEY = process.env.PRIVATE_KEY || '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80';
const signer = new ethers.Wallet(PRIVATE_KEY, provider);

// Contract Instance
const contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

async function issueCertificateOnChain(certificateHash, ipfsHash, studentId) {
    try {
        const tx = await contract.issueCertificate(certificateHash, ipfsHash, studentId);
        await tx.wait();
        return tx.hash;
    } catch (error) {
        console.error("Blockchain Issuance Error:", error.message);
        console.log("Falling back to MOCK Blockchain Transaction.");
        return "0xMOCK_TRANSACTION_HASH_" + Math.random().toString(36).substring(7);
    }
}

async function verifyCertificateOnChain(certificateHash) {
    try {
        // Returns [isValid, ipfsHash, issuer, issueDate]
        const result = await contract.verifyCertificate(certificateHash);
        return {
            isValid: result[0],
            ipfsHash: result[1],
            issuer: result[2],
            issueDate: new Date(Number(result[3]) * 1000)
        };
    } catch (error) {
        console.error("Blockchain Verification Error:", error.message);
        return null; // Return null so backend falls back to DB
    }
}

async function revokeCertificateOnChain(certificateHash) {
    try {
        const tx = await contract.revokeCertificate(certificateHash);
        await tx.wait();
        return tx.hash;
    } catch (error) {
        console.error("Blockchain Revocation Error:", error.message);
        console.log("Falling back to MOCK Blockchain Transaction.");
        return "0xMOCK_REVOKE_HASH_" + Math.random().toString(36).substring(7);
    }
}

module.exports = { issueCertificateOnChain, verifyCertificateOnChain, revokeCertificateOnChain };
